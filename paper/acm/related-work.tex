
\noindent
\emph{Related Work}.
Low-level implementations of mathematical constructs have been formalized and manually proved in proof assistants~\cite{Aff13,ANY12,AM07,MG07,M:13:PPVB}.
A semi-automatic approach~\cite{C:14:VCS} has successfully verified a hand-optimized assembly implementation of the Montgomery Ladderstep with SMT solvers, manual program annotation, and a few \coq proofs.
A C implementation of the Montgomery Ladderstep has been automatically verified with \gfverif~\cite{BS:16:GFEV}.
Re-implementations of mathematical constructs in F*~\cite{project:everest} have been verified using a combination of SMT solving and manual proofs.
Vale~\cite{B:17:VVHP} provides a meta language for defining syntax and semantics of assembly code.
Several algorithms have been implemented in Vale and verified using SMT solvers with the help of manually constructed lemmas.
Several cryptographic implementations in C and Java have been automatically verified by SAW to be equivalent to their reference implementations written in Cryptol~\cite{T:16:AVRWCI} but the correctness of reference implementations is not proven and the verification results are not certified.
The \openssl implementations of SHA-256 and HMAC have been formalized and manually proved in \coq~\cite{A:15:VCPS,B:15:VCSOH}.
Synthesis of assembly codes for mathematical constructs has been proposed in~\cite{fiat:crypto}.
Although the synthesized codes are correct by construction, they are not as efficient as hand-optimized assembly implementations.





\hide{
\cite{AM07} manually prove low-level implementations in SmartMIPS with \coq
\cite{ANY12}
\cite{AFF13} introduce a formalization of data structures for signed multi-precision arithmetic and we experiment it with formal verification of basic functions, using Separation logic
\cite{MG07} Hoare Logic, HOL4, ARM


One approach is to re-implement cryptographic protocols in languages and frameworks that allow efficient verification.
The most extensive work in this area is miTLS, a ``verified reference implementation of the TLS protocol''~\cite{B:14:VRTI,B:13:ITVCS}.
This implementation of TLS is written in F\# and specified in F7 -- the clear focus is on a verifiable (and verified)
re-implementation; not on verifying existing high-speed cryptographic software.
Note that miTLS relies on (unverified)
``cryptographic providers such as .NET or Bouncy Castle''
for core cryptographic primitives.
Also the \cryptver project~\cite{cryptver} aims at re-implementing cryptography such that it can be formally verified.
Their approach is to specify cryptographic algorithms in higher-order logic
and then implement them by formal deductive compilation.

Another approach to formally verified cryptographic software are special-domain compilers.
A recent example of this is~\cite{ABBD13},
where Almeida et al. introduce
\emph{security-aware compilation} of a subset of the C programming language.

The theory of elliptic curve has been formalized in~\cite{TH07,Bar11}.
In principle, the mathematical formulas in Curve25519 Diffie-Hellman
key-exchange can be verified with the formalization.
Low-level machine codes have been formalized in proof
assistants~\cite{Aff13,ANY12,AM07,MG07}. Large-integer arithmetic and
cryptographic functions can be formally verified semi-automatically.
Our approach is very lightweight. Most of the verification is
performed by an SMT solver automatically. It hence requires much less
human intervention.
}

%%% Local Variables:
%%% mode: latex
%%% eval: (TeX-PDF-mode 1)
%%% eval: (TeX-source-correlate-mode 1)
%%% TeX-master: "certified_vcg"
%%% End:

Algebraic specifications in \bvdsl are transformed to polynomial polynomial equation entailment problems via \zdsl.
A program in \zdsl is but a straight line of variable assignments on expressions.
Consider the following syntactic classes:
\[
\begin{array}{rcl}
  \Nat & ::= & {0}\ |\ {1}\ |\ {2}\ |\ \cdots \\
  \Int & ::= & \cdots \ |\ {-2}\ |\ {-1} \ |\ 0\ |\ {1}\ |\ {2}\ |\ \cdots \\
  \zExpr & ::= & \Int \ |\ \Var \ |\  {-}\zExpr \ |\
                 \zExpr {+} \zExpr \ |\ \zExpr {-} \zExpr \\
  & & |\ \zExpr {\times} \zExpr  \ |\ \dslcode{Pow} (\zExpr, \Nat)
\end{array}
\]

We allow exact integers as constants in \zdsl.
Variables are thus integer variables. An expression can be a
constant, a variable, or a negative expression. Additions, subtractions,
and multiplications of expressions are available.
The expression $\dslcode{Pow}(e, n)$ denotes $e^n$ for any expression $e$ and natural number $n$.
More formally, let $\zSt \defn \Var \rightarrow
\bbfZ$ and $\zst \in \zSt$ be a state. That is,
a {state} $\zst$ is a mapping from variables to integers. Define the
semantic function $\valueof{e}(\zst)$ as follows.
\[
\begin{array}{rcl}
  \valueof{{i}}(\zst) & \defn & i \textmd{  for ${i} \in \Int$} \\
  \valueof{{v}}(\zst) & \defn & \zst({v}) \textmd{  for ${v} \in \Var$} \\
  \valueof{-e}(\zst) & \defn & -_{\bbfZ}\valueof{e}(\zst) \\
  \valueof{e_0 + e_1}(\zst) & \defn & \valueof{e_0}(\zst) +_{\bbfZ} \valueof{e_1}(\zst) \\
  \valueof{e_0 - e_1}(\zst) & \defn & \valueof{e_0}(\zst) -_{\bbfZ} \valueof{e_1}(\zst) \\
  \valueof{e_0 \times e_1}(\zst) & \defn & \valueof{e_0}(\zst) \times_{\bbfZ} \valueof{e_1}(\zst) \\
  \valueof{\dslcode{Pow}(e, n)}(\zst) & \defn & (\valueof{e}(\zst))^{\valueof{n}(\zst)}
\end{array}
\]

\hide{
Note that there is no expression for quotients, or bitwise logical
operations in \zdsl. Bitwise left shifting however can be modeled by
multiplying $\dslcode{Pow}(2, n)$. Although \zdsl models a (very) 
small subset of assembly, it suffices to encode low-level
mathematical constructs in X25519.
}

In \zdsl, only assignments are allowed.
The statement $v \leftarrow e$ assigns the value of $e$
to the variable $v$. For bounded additions, multiplications, and right
shifting, they are modeled by the construct $\dslcode{Split}$ in \zdsl.
The statement $\concat{v_h}{v_l} \leftarrow
\dslcode{Split}(e, n)$ splits the value of $e$ into two parts;
the lowest $n$ bits are stored in $v_l$ and the remaining higher bits
are stored in $v_h$.
Consider the relation $\zTr \subseteq \zSt \times \zStmt \times \zSt$ defined
by $(\zst, v \leftarrow e, \zst\mymapsto{v}{\valueof{e}(\zst)}) \in \zTr$, and
  $(\zst, \concat{v_h}{v_l} \leftarrow \dslcode{Split} (e, n),
  \zst\mymapsto{v_h}{\mathit{hi}}\mymapsto{v_l}{\mathit{lo}}) \in \zTr$
where
$\mathit{hi} = (\valueof{e}(\zst) - lo) \div 2^{\valueof{n}(\zst)}$ and
$\mathit{lo} = \valueof{e}(\zst) \mod 2^{\valueof{n}(\zst)}$.
Intuitively, $(\zst, s, \zst') \in \zTr$ denotes that the state $\zst$ transits to
the state $\zst'$ after executing the statement $s$.
\begin{eqnarray*}
  \zStmt & ::= & \Var \leftarrow \zExpr
            \ |\  \concat{\Var}{\Var} \leftarrow \dslcode{Split} (\zExpr, \Nat) \\
  \zProg & ::= & \epsilon \ |\ \zStmt; \zProg
\end{eqnarray*}
A program is a sequence of statements. Again, we denote the empty program by
$\epsilon$.
\hide{
Observe that conditional branches are not allowed in our
domain specific language to prevent timing attacks.
}
The semantics of a program is defined by the relation
$\zTr^* \subseteq \zSt \times \zProg \times \zSt$ where
$(\zst, \epsilon, \zst) \in \zTr^*$ and
$(\zst, s; p, \zst'') \in \zTr^* \textmd{ if }
    \textmd{there is a } \zst' \textmd{ with }
    (\zst, s, \zst') \in \zTr$ and
    $(\zst, p, \zst'') \in \zTr^*$.
We write $\zst \goesto{p} \zst'$ when $(\zst, p, \zst') \in \zTr^*$.

\hide{
For algebraic specifications in \zdsl, $\top$ denotes the Boolean value
$\mathit{tt}$. We admit polynomial equations $e = e'$ and modular
polynomial equations $e \equiv e' \mod n$ as atomic predicates.
A \emph{predicate} $q \in \zPred$ is a conjunction of atomic
predicates. For
$\zst \in \zSt$, write $\bbfZ \models q[\zst]$ if $q$
evaluates to $\btt$ after replacing each variable $v$ with
$\zst(v)$; $\zst$ is called a \emph{$q$-state}.
\begin{eqnarray*}
  \Pred & ::= & \top
     \ |\   \Expr = \Expr
     \ |\   \Expr \equiv \Expr \mod \Nat
     \ |\   \Pred \wedge \Pred\\
  \Spec & ::= & \cond{\Pred} \Prog \cond{\Pred}
\end{eqnarray*}
We follow Hoare's formalism in algebraic specifications of
mathematical constructs~\cite{H:69:ABCP}. In an algebraic
specification $\hoaretriple{q}{p}{q'}$, $q$ and $q'$ are the \emph{pre}- and
\emph{post-conditions} of $p$ respectively. Given $q, q' \in \Pred$ and $p
\in \Prog$, $\hoaretriple{q}{p}{q'}$ is \emph{valid}
(written $\models \hoaretriple{q}{p}{q'}$) if for every $\zst, \zst' \in
\St$, $\bbfZ \models q[\zst]$ and $\zst \goesto{p} \zst'$ imply
$\bbfZ \models q'[\zst']$. Less formally, $\models
\hoaretriple{q}{p}{q'}$ if executing $p$ from a $q$-state always
results in a $q'$-state.
}

The predicates in \zdsl share the same syntax as the algebraic predicates in \bvdsl but are evaluated on $\zSt$ rather than on $\bvSt$.
For $\zst \in \zSt$ and $q \in \bvPreda$, write $\bbfZ \models q[\zst]$ if $q$ evaluates to $\btt$ after replacing each variable $v$ with $\zst(v)$.
Given $q, q' \in \bvPred$ and $p \in \zProg$, $\hoaretriple{q}{p}{q'}$ is valid (written $\models \hoaretriple{q}{p}{q'}$) if for every $\zst, \zst' \in \zSt$, $\bbfZ \models q[\zst]$ and $\zst \goesto{p} \zst'$ imply $\bbfZ \models q'[\zst']$.

\hide{
\begin{figure*}[ht]
  \centering
  \[
  \begin{array}{lclcl}
    \begin{array}{rcl}
    \textmd{1:} && {r}_0 \leftarrow {x}_0; \\
    \textmd{2:} && {r}_1 \leftarrow {x}_1; \\
    \textmd{3:} && {r}_2 \leftarrow {x}_2; \\
    \textmd{4:} && {r}_3 \leftarrow {x}_3; \\
    \textmd{5:} && {r}_5 \leftarrow {x}_4; \\
    \end{array}
    &\hspace{.05\textwidth}&
    \begin{array}{rcl}
    \textmd{6:} &&
      {r}_0 \leftarrow {r}_0 + {4503599627370458}; \\
    \textmd{7:} &&
      {r}_1 \leftarrow {r}_1 + {4503599627370494}; \\
    \textmd{8:} &&
      {r}_2 \leftarrow {r}_2 + {4503599627370494}; \\
    \textmd{9:} &&
      {r}_3 \leftarrow {r}_3 + {4503599627370494}; \\
    \textmd{10:} &&
      {r}_4 \leftarrow {r}_4 + {4503599627370494};\\
    \end{array}
    &\hspace{.05\textwidth}&
    \begin{array}{rcl}
    \textmd{11:} && {r}_0 \leftarrow {r}_0 - {y}_0; \\
    \textmd{12:} && {r}_1 \leftarrow {r}_1 - {y}_1; \\
    \textmd{13:} && {r}_2 \leftarrow {r}_2 - {y}_2; \\
    \textmd{14:} && {r}_3 \leftarrow {r}_3 - {y}_3; \\
    \textmd{15:} && {r}_4 \leftarrow {r}_4 - {y}_4;
    \end{array}
  \end{array}
  \]
  \caption{Subtraction \dslcode{sub} in \zdsl}
%$(\dslcode{x}_0, \dslcode{x}_1, \dslcode{x}_2, \dslcode{x}_3,
%\dslcode{x}_4, \dslcode{y}_0, \dslcode{y}_1, \dslcode{y}_2,
%\dslcode{y}_3, \dslcode{y}_4)$
  \label{figure:dsl:subtraction}
\end{figure*}
}

Now we are ready to describe the transformation from an algebraic specification in \bvdsl to a specification in \zdsl.
Given a program $p$ in \bvdsl, with the help of the function \textsc{BV2ZStmt} (Algorithm~\ref{algorithm:bv2z-stmt}), the function \textsc{BV2ZProg} (Algorithm~\ref{algorithm:bv2z-prog}) transforms $p$ to a program in \zdsl such that the following soundness theorem holds.
\begin{theorem}
  For every $q_a, q_a' \in \bvPreda$, $q_r, q_r' \in \bvPredr$, and $p \in \bvProg$, $\models \hoaretriple{q_a \wedge q_r}{p}{q_a' \wedge q_r'}$ if all the following conditions hold.
  \begin{itemize}
  \item[C1] The program $p$ neither overflows nor underflows under the assumption that the range precondition $q_r$ holds.
  \item[C2] $\models \hoaretriple{q_r}{p}{q_r'}$.
  \item[C3] $\models \hoaretriple{q_a}{\textsc{BV2ZProg}(p)}{q_a'}$.
  \end{itemize}
  \label{theorem:bv2z}
\end{theorem}
As conditions C1 and C2 involve only bit-vector operations, both conditions can be verified by translations to the QF\_BV fragment (quantifier-free formulas over the theory of fixed-size bit-vectors) of SMT similar to the approach in~\cite{C:14:VCS}.
Additionally, correctness of our translations from conditions C1 and C2 to QF\_BV formulas is proved and certified by \coq.
Condition C3 is verified by a transformation to polynomial equation entailment to be introduced in the next section.
Note that the inverse implication of Theorem~\ref{theorem:bv2z} does not hold because for example, $\models \hoaretriple{q_r}{p}{q_r'}$ may require that $q_a$ holds initally but we do not consider any algebraic predicates in verifying range specifications.

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{BV2ZStmt}{$s$}
    \Match{$s$}
      \Case{$v \leftarrow a$}
        \Return $v \leftarrow a$
      \EndCase
      \Case{$v \leftarrow a_1 + a_2$}
        \Return $v \leftarrow a_1 + a_2$
      \EndCase
      \Case{$c\ v \leftarrow a_1 + a_2$}
        \Return $\concat{c}{v} \leftarrow \dslcode{Split}(a_1 + a_2, w)$
      \EndCase
      \Case{$v \leftarrow a_1 + a_2 + y$}
        \Return $v \leftarrow a_1 + a_2 + y$
      \EndCase
      \Case{$c\ v \leftarrow a_1 + a_2 + y$}
        \Return $\concat{c}{v} \leftarrow \dslcode{Split}(a_1 + a_2 + y, w)$
      \EndCase
      \Case{$v \leftarrow a_1 - a_2$}
        \Return $v \leftarrow a_1 - a_2$
      \EndCase
      \Case{$v \leftarrow a_1 \times a_2$}
        \Return $v \leftarrow a_1 \times a_2$
      \EndCase
      \Case{$h\ l \leftarrow a_1 \times a_2$}
        \Return $\concat{h}{l} \leftarrow \dslcode{Split}(a_1 \times a_2, w)$
      \EndCase
      \Case{$v \leftarrow a << n$}
        \Return $v \leftarrow a \times \dslcode{Pow}(2, |n|)$
      \EndCase
      \Case{$h\ l \leftarrow a@n$}
        \Return $\concat{h}{l} \leftarrow \dslcode{Split}(a, |n|)$
      \EndCase
      \Case{$h\ l \leftarrow (a_1.a_2)@n$}
        \Return $\concat{h}{l} \leftarrow \dslcode{Split}(a_1 \times \dslcode{Pow}(2, w) + a_2, w - |n|)$
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Transformation from $\bvStmt$ to $\zStmt$ ($w$ is the fixed wordsize)}
  \label{algorithm:bv2z-stmt}
\end{algorithm}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{BV2ZProg}{$p$}
    \Match{$p$}
      \Case{$\epsilon$} \Return{$\epsilon$} \EndCase
      \Case{$s; pp$} \Return{\Call{BV2ZStmt}{$s$}; \Call{BV2ZProg}{$pp$}} \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Transformation from $\bvProg$ to $\zProg$}
  \label{algorithm:bv2z-prog}
\end{algorithm}

The example program \dslcode{subSSA} only contains statements involving addition and subtraction and thus \textsc{BV2ZProg}(\dslcode{subSSA}) looks exactly the same as \dslcode{subSSA}.

\hide{
Figure~\ref{figure:dsl:subtraction} gives a simple yet real
implementation of subtraction over $\bbfGF(\myprime)$.
In the figure, a number in $\bbfGF(\varrho)$
is represented by five 51-bit non-negative integers. The variables
${x}_0, {x}_1, {x}_2, {x}_3, {x}_4$ for instance represent
$\mathit{radix51}({x}_4, {x}_3, {x}_2, {x}_1, {x}_0) \defn
2^{51 \times 4} {x}_4 + 2^{51 \times 3} {x}_3 +
2^{51 \times 2} {x}_2 + 2^{51 \times 1} {x}_1 +
2^{51 \times 0} {x}_0$. The result of
subtraction is stored in the variables ${r}_0, {r}_1, {r}_2, {r}_3, {r}_4$.
Given $0 \leq {x}_0,$ ${x}_1,$ ${x}_2,$ ${x}_3,$ ${x}_4,$ ${y}_0,$
${y}_1,$ ${y}_2,$ ${y}_3,$ ${y}_4 < 2^{51}$,
the algebraic specification of the mathematical construct is therefore
\[
\begin{array}{rcl}
\cond{\top} &
\dslcode{sub} &
\cond{
   \begin{array}{c}
     \mathit{radix51}({x}_4, {x}_3, {x}_2, {x}_1, {x}_0) -
     \mathit{radix51}({y}_4, {y}_3, {y}_2, {y}_1, {y}_0)\\
     \equiv
     \mathit{radix51}({r}_4, {r}_3, {r}_2, {r}_1, {r}_0)
     \mod \myprime
   \end{array}
}.
\end{array}
\]

Note that the variables ${r}_i$'s are added with constants
after they are initialized with ${x}_i$'s but before
${y}_i$'s are subtracted from them. It is not hard to see that
$2\myprime = \mathit{radix51}$ $(4503599627370494,$ $4503599627370494,$
$4503599627370494,$ $4503599627370494,$ $4503599627370458)$
after tedious computation. Hence $\mathit{radix51}({r}_4,$
${r}_3,$ ${r}_2,$ ${r}_1,$ ${r}_0)$ $=$
$\mathit{radix51}({x}_4,$ ${x}_3,$ ${x}_2,$ ${x}_1,$ ${x}_0)$ $+$ 
$2 \myprime $ $-$
$\mathit{radix51}({y}_4,$ ${y}_3,$ ${y}_2,$ ${y}_1,$ ${y}_0)$ 
$\equiv $
$\mathit{radix51}({x}_4,$ ${x}_3,$ ${x}_2,$ ${x}_1,$ ${x}_0)$ $-$
$\mathit{radix51}({y}_4,$ ${y}_3,$ ${y}_2,$ ${y}_1,$ ${y}_0)$ $\mod 
\ \myprime$. The program in
Figure~\ref{figure:dsl:subtraction} is correct. 
Characteristics of large Galois fields are
regularly exploited in mathematical constructs for correctness and
efficiency. Our domain specific language can easily model such
specialized programming techniques. Indeed,
the reason for
adding constants is to prevent underflow. If the constants were not
added, the subtraction in lines~11 to 15 could give negative and hence
%
incorrect results. {Please note that ranges are a complicated
  issue. The subtraction in Figure~\ref{figure:dsl:subtraction} gives results that are correct
  but possibly {overflowing} ($>\varrho$), which can and must be
  accounted for later.} 
}

%%% Local Variables: 
%%% mode: latex
%%% eval: (TeX-PDF-mode 1)
%%% eval: (TeX-source-correlate-mode 1)
%%% TeX-master: "certified_vcg"
%%% End: 

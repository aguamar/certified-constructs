
Consider the problem of checking $\models \hoaretriple{q}{p}{q'}$ for
arbitrary $q, q' \in \Pred$ and $p \in \Prog$. Since $q'$ is arbitrary, the
program $p$ may contain fragments irrevelant to $q'$. Program slicing
is a simple yet effective technique to improve efficiency of
verification through simplifying programs~\cite{W:81:PS}.

Here we slice programs in a backward manner. We initialize the set
of \emph{cared} variables to be the variables appeared in the
post-condition $q'$. Starting from the last statement, we check if
it assigns any cared variables. If not, we skip the last statement and
move to the last but one statement. If it does, we keep the last
statement, update the cared variables, and examine the second-to-last
statement. This process repeats until all statements of the
program are processed.

Our program slicing algorithm requires several auxiliary functions. 
Algorithm~\ref{algorithm:variables-in-expressions} shows how to
compute all variables occurred in an expression by a structural
induction. If the given expression is an integer,
the empty set is returned; if it is a variable, the singleton with the
variable is returned. Variables in other expressions are computed
recursively. 

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{VarsInExpr}{$e$}
    \Match{$e$}
      \Case{$v$}
        \Return $\{ v \}$
      \EndCase
      \Case{$i$}
        \Return $\emptyset$
      \EndCase
      \Case{$-e'$}
        \Return \Call{VarsInExpr}{$e'$}
      \EndCase
      \Case{$e' + e''$}
        \Return \Call{VarsInExpr}{$e'$} $\cup$ \Call{VarsInExpr}{$e''$}
      \EndCase
      \Case{$e' - e''$}
        \Return \Call{VarsInExpr}{$e'$} $\cup$ \Call{VarsInExpr}{$e''$}
      \EndCase
      \Case{$e' \times e''$}
        \Return \Call{VarsInExpr}{$e'$} $\cup$ \Call{VarsInExpr}{$e''$}
      \EndCase
      \Case{$\dslcode{Pow}(e', \uscore)$}
        \Return \Call{VarsInExpr}{$e'$}
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Variables Occurred in Expressions}
  \label{algorithm:variables-in-expressions}
\end{algorithm}

\begin{algorithm}
\begin{algorithmic}[1]
  \Function{VarsInPred}{$q$}
  \Match{$q$}
    \Case{$\top$}
      \Return $\emptyset$
    \EndCase
    \Case{$e' = e''$}
      \Return \Call{VarsInExpr}{$e'$} $\cup$ \Call{VarsInExpr}{$e''$}
    \EndCase
    \Case{$e' \equiv e'' \mod \uscore$}
      \Return \Call{VarsInExpr}{$e'$} $\cup$ \Call{VarsInExpr}{$e''$}
    \EndCase
    \Case{$q' \wedge q''$}
      \Return \Call{VarsInPred}{$q'$} $\cup$ \Call{VarsInPred}{$q''$}
    \EndCase
  \EndMatch
  \EndFunction
\end{algorithmic}
\caption{Variables Occurred in Predicates}
\label{algorithm:variables-in-predicates}
\end{algorithm}

Similarly, Algorithm~\ref{algorithm:variables-in-predicates} computes
the variables appeared in a predicate. Using the \coq specification
langauge \gallina, both algorithms are specified in the proof
assistant easily. 

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{SliceStatement}{$\mathit{vars}$, $s$}
    \Match{$s$}
      \Case{$v \leftarrow e$}
        \IfThenElse{$v \in \mathit{vars}$}
          {\Return $\langle$\Call{VarsInExpr}{$e$} 
            $\cup$ $(\mathit{vars} \setminus \{ v \})$, $s \rangle$}
          {\Return $\mathit{vars}$}
      \EndCase
      \Case{$\concat{v_h}{v_l} \leftarrow \dslcode{Split} (e, \uscore)$}
        \IfThenElse{$v_h$ or $v_l \in \mathit{vars}$}
          {\Return $\langle$\Call{VarsInExpr}{$e$} $\cup$ 
            $(\mathit{vars} \setminus \{ v_h, v_l \})$, $s \rangle$}
          {\Return $\mathit{vars}$}
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Slicing Statements}
  \label{algorithm:slicing-statements}
\end{algorithm}

For each statement, we check if the variables in the left hand side are
cared variables. If these variables are not, we leave the cared
variables intact. If they are cared variables, we update the cared
variables by excluding the variables on the left hand side but adding
the variables appeared on the right hand
side~(Algorithm~\ref{algorithm:slicing-statements}). In the algorithm, 
the parameter $\mathit{vars}$ denotes the set of cared variables.
If the given statement assigns to a cared variable, it is returned
with the updated cared variables by the algorithm. Otherwise, only
cared variables are returned.

To slice a program, our algorithm proceeds from the last statement
(Algorithm~\ref{algorithm:slicing-programs}). It invokes
\textsc{SliceStatement} to see if the current statement is relevant
and update cared variables if necessary. The algorithm recurses with
the updated cared variables and all but the last statements.

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{SliceProg}{$\mathit{vars}$, $p$}
    \Match{$p$}
      \Case{$\epsilon$}
        \Return $\epsilon$
      \EndCase
      \Case{$pp; s;$}
        \Match{\Call{SliceStatement}{$\mathit{vars}$, $s$}}
          \Case{$\mathit{vars}'$}
            \Return \Call{SliceProg}{$\mathit{vars}'$, $pp;$}
          \EndCase
          \Case{$\langle \mathit{vars}'$, $s' \rangle$}
            \Return \Call{SliceProg}{$\mathit{vars}'$, $pp$}$\ s';$
          \EndCase
        \EndMatch
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Slicing Programs}
  \label{algorithm:slicing-programs}
\end{algorithm}

Algorithms~\ref{algorithm:slicing-statements}
and~\ref{algorithm:slicing-programs} are specified in \gallina. Their
properties are 
also specified and proven formally in \coq. Particularly, the
soundness and completeness of our program slicing algorithm have been
certified in the proof assistant. Formally, we have the following theorem:

\begin{theorem}
  For every $q, q' \in \Pred$ and $p \in \Prog$,
  \begin{center}
  $\models \hoaretriple{q}{p}{q'}$ if and only if
  $\models \hoaretriple{q}{\textsc{SliceProg}(\textsc{VarsInPred}(q'), p)}
  {q'}$.
  \end{center}
  \label{theorem:program-slicing}
\end{theorem}
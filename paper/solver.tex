
By Theorem~\ref{theorem:program-to-q-soundness}, it remains to show 
that 
\[
\begin{array}{l}
  \bbfZ \models \forall \vx. % \in \bbfZ^{|\vx|}.
  \bigwedge\limits_{i \in [I]} e_i (\vx) = e'_i (\vx) \wedge
  \bigwedge\limits_{j \in [J]} f_j (\vx) \equiv f'_j (\vx) \mod n_j
  \implies
  \\
  \hspace{.3\textwidth}
  \bigwedge\limits_{k \in [K]} g_k (\vx) = g'_k (\vx) \wedge
  \bigwedge\limits_{l \in [L]} h_l (\vx) \equiv h'_l (\vx) \mod m_l
\end{array}
\]
where
$e_i (\vx), e'_i (\vx), f_j (\vx), f'_j (\vx),
 g_k (\vx), g'_k (\vx), h_l (\vx), h'_l (\vx) \in
 \bbfZ[\vx]$, $n_j, m_l \in \bbfN$ for $i \in [I]$, $j \in [J]$, $k
 \in [K]$, and $l \in [L]$. Since the
implicant is a conjunction of (modulo) equations, it suffces to 
prove one conjunct at a time. That is, we aim to show that 
\begin{equation}
  \label{eq:polynomial-equation-implicant}
  \bbfZ \models \forall \vx. % \in \bbfZ^{|\vx|}.
  \bigwedge\limits_{i \in [I]} e_i (\vx) = e'_i (\vx) \wedge
  \bigwedge\limits_{j \in [J]} f_j (\vx) \equiv f'_j (\vx) \mod n_j
  \implies
  g (\vx) = g' (\vx); \textmd{ or}
\end{equation}
 \begin{equation}
   \label{eq:modular-polynomial-equation-implicant}
   \bbfZ \models \forall \vx. % \in \bbfZ^{|\vx|}.
   \bigwedge\limits_{i \in [I]} e_i (\vx) = e'_i (\vx) \wedge
   \bigwedge\limits_{j \in [J]} f_j (\vx) \equiv f'_j (\vx) \mod n_j
   \implies
   h (\vx) \equiv h' (\vx) \mod m
 \end{equation}
where $e_i (\vx), e'_i (\vx), f_j (\vx), f'_j (\vx), h (\vx), h' (\vx)
\in \bbfZ[\vx]$ for $i \in [I], j \in [J]$, and $m \in \bbfN$. 

It is not hard to rewrite modular polynomial equations in antecedents
of (\ref{eq:polynomial-equation-implicant}) and 
(\ref{eq:modular-polynomial-equation-implicant}) to polynomial
equations~\cite{H:07:AENTP}. By definition of modular polynomial equations,
(\ref{eq:polynomial-equation-implicant}) is equivalent to
\[
\bbfZ \models \forall \vx. % \in \bbfZ^{|\vx|}.
\bigwedge\limits_{i \in [I]} e_i (\vx) = e'_i (\vx) \wedge
\bigwedge\limits_{j \in [J]} [\exists d_j. f_j (\vx) = f'_j (\vx) + d_j \cdot n_j]
\implies
g (\vx) = g' (\vx),
\]
which in turn is equivalent to
\[
\bbfZ \models \forall \vx \forall \vd. % \in \bbfZ^{|\vx|} \vd \in \bbfZ^{J}.
\bigwedge\limits_{i \in [I]} e_i (\vx) = e'_i (\vx) \wedge
\bigwedge\limits_{j \in [J]} f_j (\vx) = f'_j (\vx) + d_j \cdot n_j
\implies
g (\vx) = g' (\vx).
\]

In other words, it suffices to consider the 
\emph{polynomial equation entailment} problem which checks
\begin{equation}
  \label{eq:reduced-polynomial-equation-implicant}
  \bbfZ \models \forall \vx. % \in \bbfZ^{|\vx|}.
  \bigwedge\limits_{i \in [I]} e_i (\vx) = e'_i (\vx)
  \implies
  g (\vx) = g' (\vx); \textmd{ or}
\end{equation}
 \begin{equation}
   \label{eq:reduced-modular-polynomial-equation-implicant}
   \bbfZ \models \forall \vx. % \in \bbfZ^{|\vx|}.
   \bigwedge\limits_{i \in [I]} e_i (\vx) = e'_i (\vx)
   \implies
   h (\vx) \equiv h' (\vx) \mod m
 \end{equation}
hold where $e_i (\vx), e'_i (\vx), h (\vx), h' (\vx) \in \bbfZ[\vx]$ for $i
\in [I]$ and $m \in \bbfN$~\cite{H:07:AENTP}.

We solve the polynomial equation entailment
problems~(\ref{eq:reduced-polynomial-equation-implicant}) 
and~(\ref{eq:reduced-modular-polynomial-equation-implicant}) via
the ideal membership problem~\cite{H:07:AENTP,BS:16:GFEV}. 
For~(\ref{eq:reduced-polynomial-equation-implicant}), consider the
ideal $I = \langle e_i(\vx) - e'_i(\vx) \rangle_{i \in [I]}$. Suppose
$g(\vx) - g'(\vx) \in I$. Then there are $u_i(\vx) \in \bbfZ[\vx]$
(called \emph{witnesses}) such that 
\begin{equation}
  \label{eq:reduced-polynomial-equation-witnesses}
  g(\vx) - g'(\vx) = \sum\limits_{i \in [I]} u_i (\vx) [e_i (\vx) - e'_i (\vx)].
\end{equation}
Hence $g(\vx) - g'(\vx) = 0$ follows from  the polynomial equations
$e_i (\vx) = e'_i (\vx)$ for $i \in [I]$ in the antecedents
in~(\ref{eq:reduced-polynomial-equation-implicant}). Similarly, it
suffices to check if $h(\vx) - h'(\vx) \in \langle m, e_i(\vx) -
e'_i(\vx) \rangle_{i \in [I]}$
for~(\ref{eq:reduced-modular-polynomial-equation-implicant}).
If so, there are $u, u_i(\vx) \in \bbfZ[\vx]$ such that
\begin{equation}
  \label{eq:reduced-modular-polynomial-equation-witnesses}
  h(\vx) - h'(\vx) = u(\vx) \cdot m + \sum\limits_{i \in [I]} u_i (\vx)
  [e_i (\vx) - e'_i (\vx)]. 
\end{equation}
Thus $h(\vx) \equiv h'(\vx) \mod m$ as required.
The reduction to the ideal membership problem however is sound but
incomplete. Consider, for instance, $\bbfZ \models \forall x. x^2 + x
\equiv 0 \mod 2$ but $x^2 + x \not\in \langle 2
\rangle$~\cite{H:07:AENTP}. 

The ideal membership problem can be solved by finding a Gr\"obner
basis for the ideal. Two \coq tactics are available to
find formal proofs for the polynomial equation entailment
problems~\cite{P:08:CGBP,P:10:CGBP}. 
The tactic \dslcode{nsatz} proves the entailment problem of
the form in~(\ref{eq:reduced-polynomial-equation-implicant}); the
tactic \dslcode{gbarith} is able to prove the form
in~(\ref{eq:reduced-modular-polynomial-equation-implicant}). 
Both tactics solve the polynomial equation entailment problem by
computing Gr\"obner bases for induced ideals. Finding Gr\"obner bases
for ideals however is NP-complete because it allows us to solve a
system of equations over the Boolean field~\cite{GJ:1979:CAI}. 
For mathematical constructs, their low-level implementations can have
hundreds of polynomial equations 
in~(\ref{eq:reduced-polynomial-equation-implicant})
or~(\ref{eq:reduced-modular-polynomial-equation-implicant}). 
Both \coq tactics are unable to finish the proof in a reasonable
amount of time. 

We develop two heuristics to effectively solve the polynomial equation
entailment problem. For the polynomial equations generated by
$\textsc{ProgToPolyEQ}(p)$
(Algorithm~\ref{algorithm:polynomial-programs}), they are of the  
following form: $x = e$ (from assignment statements) or $x + 2^c y
= e$ (from \dslcode{Split} statements). Such polynomial equations can
safely be removed after every occurrences of $x$ are replaced with $e$
or $e - 2^c y$ respectively. The number of polynomial equations and
hence the generator of the induced ideal will
be reduced after substitution. We define a \coq
tactic to simplify polynomial equation entailment problems by 
rewriting variables and then removing polynomial equations.

To further improve scalability, we use the computer algebra system
\singular to solve the ideal membership problem. From any polynomial
equation entailment problem, the corresponding ideal membership
problem is computed. We submit the membership problem to \singular and
ask the computer algebra system to return witnesses if any. Our \coq
tactic then certifies the witnesses by checking the
equation~(\ref{eq:reduced-polynomial-equation-witnesses})
or~(\ref{eq:reduced-modular-polynomial-equation-witnesses}). Only when
\coq formally verifies witnesses to the induced ideal
membership problem can our tactic solve the polynomial equation
entailment problem.

%%% Local Variables: 
%%% mode: latex
%%% eval: (TeX-PDF-mode 1)
%%% eval: (TeX-source-correlate-mode 1)
%%% TeX-master: "certified_vcg"
%%% End: 

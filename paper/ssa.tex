
A program is in \emph{static single assignment} form if every variable
is assigned at most once~\cite{AWZ:88:DQVP}.
Our next task is to correctly transform any
program specification $\hoaretriple{q}{p}{q'}$ to static single 
assignments for any $q, q' \in \Pred$ and $p \in \Prog$. Our transformation
maintains a finite mapping $\theta$ from program variables to
non-negative integers. For any variable $v$, $v^{\theta(v)}$ is
the most recently assigned copy of $v$. Only the most recent copies of
variables are referred in
expressions. Algorithm~\ref{algorithm:ssa-expressions} shows how 
to transform expressions with the finite mapping $\theta$ by a
structural induction. For each variable, its most recent copy is
returned by looking up the mapping $\theta$. Integers are
unchanged. Other expressions are transformed recursively.

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{SSAExpr}{$\theta$, $e$}
    \Match{$e$}
      \Case{$v$} \Return $v^{\theta(e)}$ \EndCase
      \Case{$i$} \Return $i$ \EndCase
      \Case{$-e'$} \Return $-$\Call{SSAExpr}{$\theta$, $e'$} \EndCase
      \Case{$e' + e''$} 
        \Return \Call{SSAExpr}{$\theta$, $e'$} $+$ 
                \Call{SSAExpr}{$\theta$, $e''$}
      \EndCase
      \Case{$e' - e''$} 
        \Return \Call{SSAExpr}{$\theta$, $e'$} $-$ 
                \Call{SSAExpr}{$\theta$, $e''$}
      \EndCase
      \Case{$e' \times e''$} 
        \Return \Call{SSAExpr}{$\theta$, $e'$} $\times$ 
                \Call{SSAExpr}{$\theta$, $e''$}
      \EndCase
      \Case{$\dslcode{Pow}$($e'$, $n$)}
        \Return $\dslcode{Pow}$(\Call{SSAExpr}{$\theta$, $e'$}, $n$)
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Static Single Assignment Transformation for Expressions}
  \label{algorithm:ssa-expressions}
\end{algorithm}

Similarly, predicates must refer to most recent copies of 
variables. They are transformed according to the finite mapping
$\theta$ (Algorithm~\ref{algorithm:ssa-predicates}). Thanks to the
formalization of finite mappings in \coq. Both
Algorithms~\ref{algorithm:ssa-expressions}
and~\ref{algorithm:ssa-predicates} are easily specified in \gallina.

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{SSAPred}{$\theta$, $q$}
    \Match{$q$}
      \Case{$\top$} \Return $\top$ \EndCase
      \Case{$e' = e''$} 
        \Return \Call{SSAExpr}{$\theta$, $e$} = \Call{SSAExpr}{$\theta$, $e'$}
      \EndCase
      \Case{$e' \equiv e'' \mod n$} 
        \Return \Call{SSAExpr}{$\theta$, $e$} $\equiv$ 
                \Call{SSAExpr}{$\theta$, $e'$} $\mod n$
      \EndCase
      \Case{$q' \wedge q''$}
        \Return \Call{SSAPred}{$\theta$, $q'$} $\wedge$
                \Call{SSAPred}{$\theta$, $q''$}
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Static Single Assignment Transformation for Predicates}
  \label{algorithm:ssa-predicates}
\end{algorithm}

Statement transformation is slightly more complicated. For
expressions on the right hand side, they are transformed by the given
finite mapping $\theta$. Algorithm~\ref{algorithm:ssa-statements} then
updates the mapping and replaces variables on the left hand side of
statements with their latest copies. In the algorithm, 
$\theta\mymapsto{v}{n}$ denotes updating the finite mapping $\theta$
by abusing the notation. 

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{SSAStmt}{$\theta$, $s$}
    \Match{$s$}
      \Case{$v \leftarrow e$}
        \State{$\theta' \leftarrow \theta\mymapsto{v}{\theta(v) + 1}$}
        \State{\Return $\langle \theta'$, 
                $v^{\theta'(v)} \leftarrow$ \Call{SSAExpr}{$\theta$, $e$}$\rangle$}
      \EndCase
      \Case{$\concat{v_h}{v_l} \leftarrow \dslcode{Split}(e, n)$}
        \State{$\theta_h \leftarrow \theta\mymapsto{v_h}{\theta(v_h) + 1}$}
        \State{$\theta_l \leftarrow \theta_h\mymapsto{v_l}{\theta_h(v_l) + 1}$}
        \State{\Return $\langle \theta_l$,
                $\concat{v_h^{\theta_h(v_h)}}{v_l^{\theta_l(v_l)}} \leftarrow
                \dslcode{Split}($\Call{SSAExpr}{$\theta$, $e$}$, n)
                \rangle$
              }
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Static Single Assignement Transformation for Statements}
  \label{algorithm:ssa-statements}
\end{algorithm}

It is now straightforward to transform programs to static single
assignment form. Using an initial mapping from variables to integers,
the transformation starts from the first statement and obtains an
updated mapping with a statement in static single assignment form. It
continues to transform the next statement with the updated mapping
(Algorithm~\ref{algorithm:ssa-programs}). 

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{SSAProg}{$\theta$, $p$}
    \Match{$p$}
      \Case{$\epsilon$}
        \Return $\langle \theta,$ $\epsilon \rangle$
      \EndCase
      \Case{$s; pp$}
        \State{$\langle \theta'$, $s' \rangle$ $\leftarrow$ 
                 \Call{SSAStmt}{$\theta$, $s$}}
        \State{$\langle \theta''$, $pp'' \rangle$ $\leftarrow$ 
                 \Call{SSAProg}{$\theta'$, $pp$}}
        \State{\Return $\langle \theta''$, $s'; pp'' \rangle$}
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Static Single Assignment for Programs}
  \label{algorithm:ssa-programs}
\end{algorithm}



With the \coq specifications, we establish the correctness of our
algorithms in two steps. We first show that the transformation indeed
produces a program in static single assignment form.
\begin{theorem}
  Let $\theta_0(v) = 0$ for every $v \in V$ and $p \in P$.
  If $\langle \hat{\theta}, \hat{p} \rangle$ $=
  \textsc{SSAProgram}(\theta_0, p)$, then 
  $\hat{p}$ is in static single assignment form.
\end{theorem}

Without loss of generality, we assume programs are well-formed. 
A program is \emph{well-formed} if
\begin{itemize}
\item for every $\concat{v_h}{v_l} \leftarrow \dslcode{Split}(e, n)$, $v_h
  \neq v_l$; and
\item every variable must be assigned to a value before being used.
\end{itemize}
Well-formedness is preserved by our transformation. Formally, we have
the following theorem.
\begin{theorem}
  Let $\theta_0(v) = 0$ for every $v \in V$ and $p \in P$ a
  well-formed program. If $\langle \hat{\theta}, \hat{p} \rangle$ $=$ 
  $\textsc{SSAProgram}(\theta_0, p)$, then $\hat{p}$ is well-formed.
\end{theorem}

The next theorem states that our transformation is both sound and
complete. That is, an algebraic specification is valid if and only if its
corresponding specification in static single assignment form is valid.
All theorems are formally certified in \coq. 
\begin{theorem}
  Let $\theta_0(v) = 0$ for every $v \in V$. For every $q, q' \in Q$
  and $p \in P$,
  \begin{center}
    $\models \hoaretriple{q}{p}{q'}$ if and only if
    $\models \hoaretriple{\textsc{SSAPred}(\theta_0, q)}
    {\hat{p}}
    {\textsc{SSAPred}(\hat{\theta}, q')}$
  \end{center}
  where $\langle \hat{\theta}, \hat{p} \rangle =
  \textsc{SSAProg}(\theta_0, p)$.
  \label{theorem:ssa}
\end{theorem}

\begin{figure}
  \centering
  \[
  \begin{array}{lclcl}
    \begin{array}{rcl}
    \textmd{1:} && {r}^0_0 \leftarrow {x}^0_0; \\
    \textmd{2:} && {r}^0_1 \leftarrow {x}^0_1; \\
    \textmd{3:} && {r}^0_2 \leftarrow {x}^0_2; \\
    \textmd{4:} && {r}^0_3 \leftarrow {x}^0_3; \\
    \textmd{5:} && {r}^0_4 \leftarrow {x}^0_4; \\
    \end{array}
    &\hspace{.05\textwidth}&
    \begin{array}{rcl}
    \textmd{6:} && 
      {r}^1_0 \leftarrow {r}^0_0 + {4503599627370458}; \\
    \textmd{7:} &&
      {r}^1_1 \leftarrow {r}^0_1 + {4503599627370494}; \\
    \textmd{8:} &&
      {r}^1_2 \leftarrow {r}^0_2 + {4503599627370494}; \\
    \textmd{9:} &&
      {r}^1_3 \leftarrow {r}^0_3 + {4503599627370494}; \\
    \textmd{10:} && 
      {r}^1_4 \leftarrow {r}^0_4 + {4503599627370494};\\
    \end{array}
    &\hspace{.05\textwidth}&
    \begin{array}{rcl}
    \textmd{11:} && {r}^2_0 \leftarrow {r}^1_0 - {y}^0_0; \\
    \textmd{12:} && {r}^2_1 \leftarrow {r}^1_1 - {y}^0_1; \\
    \textmd{13:} && {r}^2_2 \leftarrow {r}^1_2 - {y}^0_2; \\
    \textmd{14:} && {r}^2_3 \leftarrow {r}^1_3 - {y}^0_3; \\
    \textmd{15:} && {r}^2_4 \leftarrow {r}^1_4 - {y}^0_4;
    \end{array}
  \end{array}
  \]
  \caption{Subtraction \dslcode{subSSA} in Static Single Assignment Form}
% $(\dslcode{x}_0, \dslcode{x}_1, \dslcode{x}_2, \dslcode{x}_3,
% \dslcode{x}_4, \dslcode{y}_0, \dslcode{y}_1, \dslcode{y}_2,
% \dslcode{y}_3, \dslcode{y}_4)$
  \label{figure:translation:subtraction-ssa}
\end{figure}

\noindent
\emph{Example.}
Figure~\ref{figure:translation:subtraction-ssa} gives the subtraction program
\textsc{sub} in static single assignment form. Starting from $0$, the
index of a variable is incremented when the variable is assigned to an
expression. After the static single assignment translation, the
variables ${x}_i$, ${y}_i$ are indexed by $0$ and
${r}_i$ are indexed by $2$ for $0 \leq i \leq 4$. 
Subsequently, variables in pre- and post-conditions of the algebraic
specification for subtraction needs to be re-indexed. The
corresponding algebraic specification is as follows.
\[
\begin{array}{c}
\cond{\top}\\
\dslcode{subSSA}\\
% (\dslcode{x}_0, \dslcode{x}_1, \dslcode{x}_2, \dslcode{x}_3,
% \dslcode{x}_4, \dslcode{y}_0, \dslcode{y}_1, \dslcode{y}_2,
% \dslcode{y}_3, \dslcode{y}_4)\\
\cond{\mathit{radix}({x}^0_4, {x}^0_3, {x}^0_2, {x}^0_1, {x}^0_0) -
\mathit{radix51}({y}^0_4, {y}^0_3, {y}^0_2, {y}^0_1, {y}^0_0)
\equiv
\mathit{radix51}({r}^2_4, {r}^2_3, {r}^2_2, {r}^2_1, {r}^2_0)
\mod \myprime
}.
\end{array}
\]

